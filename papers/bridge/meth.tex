\section{Approach}
\label{sec:meth}

The core hypothesis of our work is that value should be conserved
within cross-chain transactions.  That is, that the value of the asset
inflow in such a transaction (i.e., the deposit) should equal the
value of the asset outflow (i.e., the withdrawal).  In token transfer
bridges, this invariant corresponds to a balancing of the inflow
tokens and the outflow tokens (less any fees or transaction costs
incurred by the bridge itself).  When this balance invariant does not
hold it allows a range of opportunities for fraud, all of which
involve greater outflows (withdrawals) than inflow
(deposits). Figure~\ref{fig:invariant} illustrates such an outcome by 
graphing the \emph{aggregate} difference between bridge inflow (on
Ethereum) and outflow (on Solana) leading up to and during the
February 2022 attack on the Wormhole bridge.  The net difference is
consistently near zero, with only short positive deviations
(representing delayed withdrawals) until the attack in January, at
which point there are significant withdrawals without matching
deposits---producing a large negative difference.

Testing this invariant on a \emph{per transaction basis} is
straightforward in principle. However, since bridge transaction formats are
not standardized, it requires a range of per-bridge and per-chain
parsing in practice.  Our methodology for normalizing this information
focuses on two key pieces of information: a) identifying each bridge
transaction---a composite of a deposit (inflow) transaction on a
source blockchain and a withdrawal (outflow) transaction on
another---and b) identifying the value transferred in each such bridge
transaction.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.7\columnwidth]{fig/sec25_plot_wormhole.pdf}
  \caption[Wormhole Attack Invariant]{Total Inflow (on Ethereum) - Total Outflow (on Solana) Over Time: Wormhole Attack in Feb 2022.}
  \label{fig:invariant}

\end{figure}


\subsection{Identifying Bridge Transactions}
For almost all bridges, identifying their component (per-chain) inflow
and outflow transactions is straightforward --- bridges typically use
explicit events on each chain to signal if a given transaction is a
deposit or withdrawal.\footnote{One key exception to this rule is the
  Wormhole bridge which, until late 2023, did not emit specific
  events when executing a withdrawal transaction.  In this case, we infer that a withdrawal took
  place by looking for transactions that invoke functions designated for performing withdrawal operations (e.g., \textit{completeTransfer}).
  %have synthesized such an event ourselves by parsing the function
  % names called by the transaction to .  
  It also appears to be widely understood today that emitting
  explicit events is a best practice.}

Pairing these component transactions (i.e., matching deposits on one
chain to withdrawals on other) can be performed in several different
ways.  The easiest, and most common, is via a unique transaction
identifier. Such IDs are typically generated by the bridge on the
\emph{source chain} during a deposit transaction and then copied into
the withdrawal transaction on the destination chain.\footnote{These
  unique IDs are commonly simple global variables incremented with
  each new transaction.}  However, instead of an explicit ID, some
bridges use a hash of the deposit transaction for the same purpose
(e.g., for Anyswap, each withdraw transaction will include the hash of
its corresponding deposit transaction).\footnote{We note that to prevent potential replay attacks, bridge implementers should also include an ID that uniquely identifies individual deposit events within a transactions. Sadly, this is often not the case.}  Finally, in a handful of cases there are
no ``inband'' identifiers that can be used to associate transactions.
We believe this is a poor design choice that is fundamentally in
conflict with auditability.  However, even in these cases, for the
purpose of our analysis we have been able to pair transactions using
explicit query APIs provided by the affected bridges
services.\footnote{For example, when a bridge transaction on the Poly
  Network bridge includes a withdrawal from Curve (a kind of liquidity
  pool) or when a bridge transaction on the Binance Token Hub includes
  a Binance Smart Chain (BSC) withdrawal, it is not possible to
  identify the partner deposit from blockchain data alone and we must
  make use of ``out of band'' data available through their respective
  bridge query APIs.}

  At the end of this process, we identify a comprehensive collection
  of ``bridge transactions'' (a pair of transactions from two
  different blockchains that were used by the bridge to transfer
  value across them). While the vast majority of bridge transactions
  are pairs of deposit and withdrawal transactions, a handful of
  bridge transactions are either withdrawal-only (e.g., in the case of
  attacks) or deposit-only (e.g., if the user chooses to delay their
  withdrawal).

% And for 
% a handful of bridge transaction, they are either withdrawal-only or deposit-only, and we treat them as singleton transactions.
%  and a handful of singleton
% transactions (i.e., which involve the bridge, based on their
% addresses, but are withdrawal-only or deposit-only).


%For example, with the Binance bridge, the matching transaction for a BSC transaction can only be identified by querying the API. 
%%% here.
%Similarly, for Poly Network bridge, when users withdraw from Curve (a kind of liquidity pool), the matching deposit amount is not recorded on the blockchain, as its a special type of withdrawal where the matching deposit is computed off-chain and only available through the API. In this case, we also rely on Poly Network's API to pair the deposit and withdraw transactions, if the deposit transaction is from Curve. \elisa{It might be nice to give a reason why the pairing info is not available for these cases if we know.} 




%\textbf{Using Unique ID.} Most of the bridges\alex{how many?} will create a unique id for each deposit transaction (incrementing by 1).
%A withdraw transaction will contain this unique id. We can then use this unique id to pair the deposit and withdraw transactions.



%\textbf{Using the transaction hash of the deposit transaction.}
%Another way to pair deposit and withdraw transactions is to use the transaction hash of the deposit transaction. A withdraw transaction will include the transaction hash of the corresponding deposit transaction hash. We can then use this information to pair the deposit and withdraw transactions.

%\textbf{Using the official API.}
%Some bridges provide APIs to query matching deposit and withdraw transactions. While this feature mostly exist for user convenience, sometimes we have to rely on this API to pair deposit and withdraw transactions, as the pairing information is not directly available as part of the withdraw transaction.\alex{maybe we should hedge here and say its not trivial to get the information.} 
%For example, with the Binance bridge, the matching transaction for a BSC transaction can only be identified by querying the API. 
%%% here.
%Similarly, for Poly Network bridge, when users withdraw from Curve (a kind of liquidity pool), the matching deposit amount is not recorded on the blockchain, as its a special type of withdrawal where the matching deposit is computed off-chain and only available through the API. In this case, we also rely on Poly Network's API to pair the deposit and withdraw transactions, if the deposit transaction is from Curve. \elisa{It might be nice to give a reason why the pairing info is not available for these cases if we know.} 

\subsection{Identifying the Value Transferred}
Many bridge transaction event formats explicitly identify the amount
and kind of tokens transferred. However, some bridges do not emit this
information and others can be unreliable.\footnote{For example, as
  mentioned earlier, pre-2024 Wormhole does not emit an event for
  withdrawal transactions. Other examples include the Meter bridge and
  Qubit bridge, which attempted to verify the number of tokens
  received but had exploitable bugs.}  In such cases, we can
frequently make use of the ERC-20 ``Transfer'' event (see
Figure~\ref{fig:erc20-event} for an example) that is emitted when the
contract transfers the tokens from the user's account to the bridge's
account.  This event contains the number of tokens transferred as well
as the sender and recipient addresses, which we use to identify the
number of tokens transferred to or from the bridge.  Because the
Transfer event is adjacent to its associated bridge-generated event,
it is easy to identify and thus establish the number of tokens
transferred.\footnote{As a sanity check, we also require that the
  sender and recipient addresses in the Transfer event are consistent
  with the bridge's defined behavior: for withdrawal transactions, we
  require that the sender is either a mint address (i.e., all-zero
  address) or a bridge-controlled address, while for deposit
  transactions, we require that the recipient is either a burn address
  (i.e., all-zero address) or a bridge-controlled address.}  In a few
implementations, multiple related Transfer events can be emitted at
once, and in these cases we have manually inspected their contracts
and constructed implementation-specific logic to account for this
behavior.  Another special case is caused by so-called ``reflection
tokens'' in which the number of tokens logged in the event (the value
field in Figure~\ref{fig:erc20-event}) is dynamically adjusted based
on a combination of the intended number and the total token supply.
For such cases, we either rely on bridge events which capture the
intended number of tokens transferred or implement token-specific
logic to recompute the value accordingly.  Finally, native tokens have
no Transfer event (since they are not ERC-20 tokens), but thus far we
have either been able to recover the number of tokens transferred from
bridge events or so-called ``internal transactions''.

To summarize, while it is certainly possible to create a bridge
transaction protocol that records insufficient data to match deposits
and withdrawals, or for which the number of tokens transferred might
be ambiguous, our empirical experience analyzing 11 bridges and 21
blockchains is that such reconstruction has always been possible.


%When the amount of tokens transferred logged by the bridge is unavailable or unreliable, we can use the Transfer event emitted by an ERC20 token contract to identify the amount of tokens transferred. The Transfer event, part of the ERC20 standard, has been used by prior research in other scenarios.\alex{cite} This event contains the amount of tokens transferred as well as the sender and recipient addresses, which we use to identify the amount of tokens transferred to or from the bridge. Concretely, we observe that for any successful bridge transaction, depending on the order of execution, the transfer event either happens right before or after the bridge-generated event. As a result, we can first locate the bridge event and then look for the Transfer event that happens right before or after the bridge event, which contains the amount of tokens transferred. As additional sanity checks, we also require that the sender and recipient addresses in the Transfer event are consistent with the bridge's behavior. Namely, for withdraw transactions, we require that the sender is either a mint address (e.g., all-zero address) or a bridge controlled address. On the other hand, for deposit transactions, we require that the recipient is either a burn address (e.g., all-zero address) or a bridge controlled address.\alex{do we have to explain the intuition?}


%There are two ways to identify the amount of tokens transferred by the bridge: using the amount logged in a 
%bridge-generated event or using the Transfer event emitted by ERC20 tokens. Specifically, some bridges include the amount of tokens sent or received in their events. However, this information is not always reliable, as bridges can have bugs (typically when they don't verify the amount of tokens they actually received), which is the case for [AL: which]. Additionally, some bridges do not emit this information. In such cases, we can use the token transfer event to identify the amount of tokens transferred, which also serves as the ground truth.

%\textbf{Identifying Token Transferred from Transfer Event.} 
%When the amount of tokens transferred logged by the bridge is unavailable or unreliable, we can use the Transfer event emitted by an ERC20 token contract to identify the amount of tokens transferred. The Transfer event, part of the ERC20 standard, has been used by prior research in other scenarios.\alex{cite} This event contains the amount of tokens transferred as well as the sender and recipient addresses, which we use to identify the amount of tokens transferred to or from the bridge. Concretely, we observe that for any successful bridge transaction, depending on the order of execution, the transfer event either happens right before or after the bridge-generated event. As a result, we can first locate the bridge event and then look for the Transfer event that happens right before or after the bridge event, which contains the amount of tokens transferred. As additional sanity checks, we also require that the sender and recipient addresses in the Transfer event are consistent with the bridge's behavior. Namely, for withdraw transactions, we require that the sender is either a mint address (e.g., all-zero address) or a bridge controlled address. On the other hand, for deposit transactions, we require that the recipient is either a burn address (e.g., all-zero address) or a bridge controlled address.\alex{do we have to explain the intuition?}

%\textbf{Additional Considerations.}
%We note a few additional considerations. First, while the transfer action usually results in a single event, there are cases where multiple Transfer events are emitted. In such cases, we need to incorporate token-specific logic to capture a series of Transfer events to identify the amount of tokens transferred. For tokens exhibiting this behavior, we manually examine their code and account for their logic in our analysis.
%Next, for transfers involving native tokens, the value sometimes is included in internal transactions, and no event is emitted. We use the internal transactions to identify the amount of tokens transferred. Lastly, for a special type of tokens called reflection tokens, we need to account for the reflection mechanism. Specifically, reflection tokens have a mechanism where the real amount of tokens transferred is dynamically adjusted based on intended amount and total supply. For some tokens, they emit events that include enough information to recompute the intended amount. We thus use this information to identify the intended amount of tokens transferred. For other tokens, they do not provide such information. However, for those cases, conveniently, the bridge event includes the intended amount of tokens transferred. We thus revert back to use the amount logged by the bridge.\footnote{The delta between the intended amount and the real amount is very small (typically within a factor of 0.01). Thus, even if the initial amount is not logged by the bridge, the intended amount can still be bounded.}

\subsection{Checking the Balance Invariant}
Once we have identified both sides of the bridge transaction and the
number of tokens transferred by the bridge, we can verify if the
balance invariant holds: for each bridge transaction (including those
that are withdrawal-only), does the number of tokens transferred from
the bridge---the withdrawal amount---match the number of tokens
received by the bridge---the deposit amount?

However, a key complication is that bridges can charge fees and, while
these fees can sometimes be paid ``out of band'', it is not uncommon
for them to be subtracted from the tokens received on deposit.  To
account for this behavior (i.e., outflow = inflow - costs), we must be
able to determine such costs on a per-transaction basis.
In most cases, fees can be accounted for in a straightforward manner:
they either are made explicit in bridge-generated events (and can thus
be accounted for directly) or can be calculated based on either
published fee schedules or inferred fee schedules (i.e., since all
transactions are typically subject to the same fixed or percentage
fees).


%In practice there are two (additional) factors that influence this
%calculation. First, tokens could have different decimals on different blockchains.
%We account for this difference by retrieving the token's decimal information on each blockchain
%and normalizing the amount of tokens transferred accordingly. More concretely, token transfer values are expressed in the smallest unit of the token.

%\deian{dont use passive voice---who expresses them?} As an example, for a token with 6 decimals, 1 token = $10^6$ units. For the amount $212295874$ in Figure~\ref{fig:erc20-event}, if the token has 6 decimals,
%the normalized amount of tokens (also known as the whole unit amount) transferred to $212295874 / 10^6 = 212.295874$. 
% this by... XXX alex... I don't understand the sentence ``by using
% the token's decimal information to normalize the amount of tokens
% transferred''.

%.  In others, they may not be reported, but
% can be calculated based on either published fee schedules or inferred
% fee schedules (i.e., since all transactions are typically subject to
% the same fixed and percentage fees).

In some cases, the precise value of fees may be difficult to determine
retrospectively because they depend on some external contemporaneous
value not recorded in the transaction (e.g., fees valued in US dollars
implicitly depend on the exchange rate of a given token at that time).
While such ambiguity could be further minimized with additional data,
in our work we manage this issue by defaulting to a simple rule
that the number of tokens withdrawn should not exceed the number
deposited.






%We note a few additional considerations here. First, we note that the amount typically includes decimals, and the same token can have different number of decimals on different blockchains. We account for this by using the token's decimal information to normalize the amount of tokens transferred. Next, for some bridges, the amount of tokens transferred is not equal to the amount of tokens received because of the bridge fee. We address this issue by using the fee information provided by the bridge. When the fee information is unclear or specified in real currency (e.g., US dollars), we simply require that the amount of tokens transferred is less than or equal to the amount of tokens received by the bridge. 

